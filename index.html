<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #input-data, #output-data {
            table-layout: fixed;
            width: 100%;
            border-collapse: collapse;
        }

        #input-data {
            border: 3px solid purple;
        }

        #output-data {
            border: 3px solid yellowgreen;
        }

        #input-data thead {
            font-weight: 600;
        }

        #input-data tbody tr:nth-child(odd) {
            background-color: #eeeeee;
        }

        thead {
            border-bottom: 2px solid;
        }

    </style>
</head>
<body>
<div style="width: 50%;float: left;">
    <h2>Output data</h2>
    <table id="output-data">

    </table>
</div>
<div style="width: 50%;float: left;">
    <h2>Input data</h2>
    <table id="input-data">

    </table>
</div>
<script>
    const data = [
        {'ID': '1', 'NAME': '1', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '1.1', 'NAME': '2', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '1.1.1', 'NAME': '3', 'PROP1': 'C', 'PROP2': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '1.1.2', 'NAME': '4', 'PROP1': 'A', 'PROP2': 'D', 'FROM': 20150515, 'TO': 20150615},
        {'ID': '1.1.3', 'NAME': '5', 'PROP1': 'B', 'PROP2': 'C', 'FROM': 20150601, 'TO': 20150615},
        {'ID': '1.2', 'NAME': '6', 'PROP1': 'A', 'PROP2': 'B', 'FROM': 20150501, 'TO': 20150615},
        {'ID': '1.3', 'NAME': '7', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '1.3.1', 'NAME': '8', 'PROP1': 'C', 'PROP2': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '2', 'NAME': '9', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '2.1', 'NAME': '10', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '2.3', 'NAME': '11', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '2.3.1', 'NAME': '12', 'PROP1': 'C', 'PROP2': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '2.1.3', 'NAME': '13', 'PROP1': 'B', 'PROP2': 'C', 'FROM': 20150601, 'TO': 20150615},
        {'ID': '2.2', 'NAME': '14', 'PROP1': 'A', 'PROP2': 'B', 'FROM': 20150501, 'TO': 20150615},
        {'ID': '2.1.1', 'NAME': '15', 'PROP3': 'C', 'PROP4': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '2.1.2', 'NAME': '16', 'PROP5': 'A', 'FROM': 20150515, 'TO': 20150615}
    ];
    const keys = ['ID', 'NAME'];

    data.forEach((row) => {
        const rowKeys = Object.keys(row);
        rowKeys.forEach((key) => {
            if (!keys.includes(key)) {
                keys.push(key);
            }
        });
    });
    const inpTable = document.getElementById('input-data');
    const tbdy = document.createElement('tbody');
    data.forEach((row) => {
        const tr = document.createElement('tr');
        keys.forEach((key) => {
            const td = document.createElement('td');
            td.appendChild(document.createTextNode(row[key] !== undefined ? row[key] : '-'));
            tr.appendChild(td)
        });
        tbdy.appendChild(tr);
    });
    const thead = document.createElement('thead');

    const tr = document.createElement('tr');
    keys.forEach((key) => {
        const td = document.createElement('td');
        td.appendChild(document.createTextNode(key));
        tr.appendChild(td)
    });
    thead.appendChild(tr);
    inpTable.appendChild(tbdy);
    inpTable.appendChild(thead);

    function compare(a, b) {
        const id_array_a = a['ID'].split('.');
        const id_array_b = b['ID'].split('.');
        const max_length = Math.max(id_array_a.length, id_array_b.length);
        for (let i = 0; i < max_length; i++) {
            if (parseInt(id_array_a[i] || 0) > parseInt(id_array_b[i] || 0)) {
                return 1;
            }
            else if (parseInt(id_array_a[i] || 0) < parseInt(id_array_b[i] || 0)) {
                return -1;
            }
        }
        return 0;
    }

    function list_to_tree(list) {
        const map = {};
        const roots = [];
        for (let i = 0; i < list.length; i++) {
            map[list[i]['ID']] = i;
            list[i].children = [];
        }
        for (let i = 0; i < list.length; i++) {
            const node = list[i];
            const parentId = node['ID'].split('.').slice(0, -1).join('.');
            if (parentId.length) {
                list[map[parentId]].children.push(node);
            } else {
                roots.push(node);
            }
        }
        return roots;
    }

    function calc(root) {
        let FROM = Infinity, TO = 0;
        for (let i = 0; i < root.children.length; i++) {
            root.children[i] = calc(root.children[i]);
            FROM = root.children[i]['FROM'] < FROM ? root.children[i]['FROM'] : FROM;
            TO = root.children[i]['TO'] > TO ? root.children[i]['TO'] : TO;
        }
        root['FROM'] = root['FROM'] !== undefined ? root['FROM'] : FROM;
        root['TO'] = root['TO'] !== undefined ? root['TO'] : TO;
        return root;
    }

    function drowTable(tree) {
        const table = document.getElementById('output-data');
        const tbdy = document.createElement('tbody');
        for (let i = 0; i < tree.length; i++) {
            tree[i].children.forEach(child => {
                tree.splice(i + 1, 0, child);
            });
            const tr = document.createElement('tr');

            if (tree[i].children.length) {
                tr.style.fontWeight = "600";
                tr.style.cursor = "pointer";
            }

            keys.forEach((key) => {
                const td = document.createElement('td');
                td.appendChild(document.createTextNode(tree[i][key] !== undefined ? tree[i][key] : '-'));
                tr.appendChild(td)
            });
            tbdy.appendChild(tr);
        }
        table.appendChild(tbdy);

        const thead = document.createElement('thead');
        const tr = document.createElement('tr');
        keys.forEach((key) => {
            const td = document.createElement('td');
            td.appendChild(document.createTextNode(key));
            tr.appendChild(td)
        });
        thead.appendChild(tr);
        table.appendChild(thead);
    }

    data.sort(compare);
    data.reverse();
    let tree = list_to_tree(data);
    tree = tree.map(root => calc(root));
    // console.log(tree);
    tree.reverse();
    drowTable(tree);

</script>
</body>
</html>