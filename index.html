<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #input-data, #output-data, #output-data table {
            table-layout: fixed;
            width: 100%;
            border-collapse: collapse;
        }

        #input-data {
            border: 3px solid purple;
        }

        #output-data {
            border: 3px solid yellowgreen;
        }

        #input-data thead {
            font-weight: 600;
        }

        #input-data tbody tr:nth-child(odd) {
            background-color: #eeeeee;
        }

        thead {
            border-bottom: 2px solid;
        }

        .hide {
            display: none;
        }

    </style>
</head>
<body>
<div style="width: 50%;float: left;">
    <h2>Output data</h2>
    <table id="output-data">

    </table>
</div>
<div style="width: 50%;float: left;">
    <h2>Input data</h2>
    <table id="input-data">

    </table>
</div>
<script>
    function renderInput(data) {
        const keys = [];
        data.forEach((row) => {
            const rowKeys = Object.keys(row);
            rowKeys.forEach((key) => {
                if (!keys.includes(key)) {
                    keys.push(key);
                }
            });
        });
        const inpTable = document.getElementById('input-data');
        const tbdy = document.createElement('tbody');
        data.forEach((row) => {
            const tr = document.createElement('tr');
            keys.forEach((key) => {
                const td = document.createElement('td');
                td.appendChild(document.createTextNode(row[key] !== undefined ? row[key] : '-'));
                tr.appendChild(td)
            });
            tbdy.appendChild(tr);
        });
        const thead = document.createElement('thead');

        const tr = document.createElement('tr');
        keys.forEach((key) => {
            const td = document.createElement('td');
            td.appendChild(document.createTextNode(key));
            tr.appendChild(td)
        });
        thead.appendChild(tr);
        inpTable.appendChild(tbdy);
        inpTable.appendChild(thead);
    }

    const data = [
        {'ID': '1', 'PROP1': 'A', 'NAME': '1', 'PROP2': 'B'},
        {'ID': '1.1', 'NAME': '2', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '1.1.1', 'NAME': '3', 'PROP1': 'C', 'PROP2': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '1.1.2', 'NAME': '4', 'PROP1': 'A', 'PROP2': 'D', 'FROM': 20150515, 'TO': 20150615},
        {'ID': '1.1.3', 'NAME': '5', 'PROP1': 'B', 'PROP2': 'C', 'FROM': 20150601, 'TO': 20150615},
        {'ID': '1.2', 'NAME': '6', 'PROP1': 'A', 'PROP2': 'B', 'FROM': 20150501, 'TO': 20150615},
        {'ID': '1.3', 'NAME': '7', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '1.3.1', 'NAME': '8', 'PROP1': 'C', 'PROP2': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '2', 'NAME': '9', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '2.1', 'NAME': '10', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '2.3', 'NAME': '11', 'PROP1': 'A', 'PROP2': 'B'},
        {'ID': '2.3.1', 'NAME': '12', 'PROP1': 'C', 'PROP2': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '2.1.3', 'NAME': '13', 'PROP1': 'B', 'PROP2': 'C', 'FROM': 20150601, 'TO': 20150615},
        {'ID': '2.2', 'NAME': '14', 'PROP1': 'A', 'PROP2': 'B', 'FROM': 20150501, 'TO': 20150615},
        {'ID': '2.1.1', 'NAME': '15', 'PROP3': 'C', 'PROP4': 'D', 'FROM': 20150501, 'TO': 20150602},
        {'ID': '2.1.2', 'NAME': '16', 'PROP5': 'A', 'FROM': 20150515, 'TO': 20150615}
    ];
    renderInput(data);

    function Tree(data) {
        this.data = data;
        this.tree = [];
        this.sortKey = 'ID';
        this._sortReverse = false;

        Object.defineProperties(this, {
            sortReverse: {
                get: () => {
                    return this._sortReverse;
                },
                set: function (sortReverse) {
                    this._sortReverse = sortReverse;
                    this.renderTable();
                }
            }
        });

        function compareById(a, b, reverse) {
            const r = !reverse ? 1 : -1;
            const id_array_a = a['ID'].split('.');
            const id_array_b = b['ID'].split('.');
            const max_length = Math.max(id_array_a.length, id_array_b.length);
            for (let i = 0; i < max_length; i++) {
                if (parseInt(id_array_a[i] || 0) > parseInt(id_array_b[i] || 0)) {
                    return r;
                }
                else if (parseInt(id_array_a[i] || 0) < parseInt(id_array_b[i] || 0)) {
                    return -1 * r;
                }
            }
            return 0;
        }

        function listToTree(list) {
            const map = {};
            const roots = [];
            for (let i = 0; i < list.length; i++) {
                map[list[i]['ID']] = i;
                list[i].children = [];
            }
            for (let i = 0; i < list.length; i++) {
                const node = list[i];
                const parentId = node['ID'].split('.').slice(0, -1).join('.');
                if (parentId.length) {
                    list[map[parentId]].children.push(node);
                } else {
                    roots.push(node);
                }
            }
            return roots;
        }

        function calcFromAndTo(root) {
            let FROM = Infinity, TO = 0;
            for (let i = 0; i < root.children.length; i++) {
                root.children[i] = calcFromAndTo(root.children[i]);
                FROM = root.children[i]['FROM'] < FROM ? root.children[i]['FROM'] : FROM;
                TO = root.children[i]['TO'] > TO ? root.children[i]['TO'] : TO;
            }
            root['FROM'] = root['FROM'] !== undefined ? root['FROM'] : FROM;
            root['TO'] = root['TO'] !== undefined ? root['TO'] : TO;
            return root;
        }

        function sortTree(tree, key, reverse) {
            tree.forEach(node => {
                if (node.children.length > 0) {
                    node.children = sortTree(node.children, key, reverse);
                }
            });

            const r = !reverse ? 1 : -1;
            tree.sort(
                key === 'ID' ?
                    (a, b) => {
                        return compareById(a, b, reverse);
                    } :
                    (a, b) => {
                        if (a[key] < b[key])
                            return -1 * r;
                        if (a[key] > b[key])
                            return r;
                        return 0;
                    });
            return tree;
        }

        function getTable(root, keys) {
            const tr_list = [];
            let tr, td, ch_table, ch_tbdy, childrens;
            // console.log(root);
            tr = document.createElement('tr');
            if (root.children.length) {
                tr.style.fontWeight = "600";
                tr.style.cursor = "pointer";
                tr.onclick = function () {
                    this.nextSibling.classList.toggle("hide");
                }
            }
            keys.forEach((key) => {
                const td = document.createElement('td');
                td.appendChild(document.createTextNode(root[key] !== undefined ? root[key] : '-'));
                tr.appendChild(td);
            });
            tr_list.push(tr);
            if (root.children.length > 0) {
                ch_table = document.createElement('table');
                ch_tbdy = document.createElement('tbody');
                root.children.forEach(node => {
                    childrens = getTable(node, keys);
                    childrens.forEach(child => {
                        ch_tbdy.appendChild(child);
                    });
                });
                ch_table.appendChild(ch_tbdy);

                tr = document.createElement('tr');
                td = document.createElement('td');
                td.colSpan = keys.length;
                td.appendChild(ch_table);
                tr.appendChild(td);
                tr.classList.add("hide");
                tr.style.backgroundColor = "rgba(0, 0, 0, 0.03)";
                tr_list.push(tr);
            }
            return tr_list;
        }

        this.drowTable = () => {
            this.tableHtml.innerHTML = '';
            const tbdy = document.createElement('tbody');
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            this.keys.forEach((key) => {
                const td = document.createElement('td');
                const sufx = this.sortKey !== key ? '' : this.sortReverse ? ' \\/' : ' /\\';
                td.appendChild(document.createTextNode(key + sufx));
                td.style.fontWeight = "600";
                td.style.cursor = "pointer";
                td.onclick = () => {
                    if (this.sortKey === key) {
                        this.sortReverse = !this.sortReverse;
                    } else {
                        this.sortKey = key;
                        this.sortReverse = false;
                    }
                };
                tr.appendChild(td)
            });
            thead.appendChild(tr);

            this.tableHtml.appendChild(thead);
            this.tree.forEach(root => {
                const childrens = getTable(root, this.keys);
                childrens.forEach(child => {
                    tbdy.appendChild(child);
                });
            });

            this.tableHtml.appendChild(tbdy);
        };

        this.renderTable = () => {
            this.tree = sortTree(this.tree, this.sortKey || 'ID', this.sortReverse !== undefined ? this.sortReverse : true);
            this.drowTable();
        };

        this.keys = ['ID', 'NAME'];
        this.data.forEach((row) => {
            const rowKeys = Object.keys(row);
            rowKeys.forEach((key) => {
                if (!this.keys.includes(key)) {
                    this.keys.push(key);
                }
            });
        });

        this.tableHtml = document.getElementById('output-data');

        this.data.sort(compareById);
        this.data.reverse();
        this.tree = listToTree(data);
        this.tree.map(root => calcFromAndTo(root));
        this.renderTable();
    }

    new Tree(data);

</script>
</body>
</html>